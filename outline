I. Level set
    a. People using / familiar with FP
    b. People using / familiar with React / Flux / Redux
    c. People using / familiar with Rx
II. Why FP
    a. Composition
    b. Immutability
    c. Reasoning
    d. HOF
III. FP in UI Dev
    a. State of FE JS Dev
    b. Moving to functional with React, Flux, Angular 2.0
IV. Why Elm
    a. Functional language designed for UI programming
        i. Reactive
        ii. Functional
        iii. Immutable
        iv. Statically typed, but with great type inference and an amazingly helpful (and fast) compiler
    b. Easy to get up and running
    c. Avoids more complex principles associated with FP (Monads, etc.)
    d. Includes many complex principles (Signals, Extenisble Records
       but provides easy ways to interact with them (Start-App)
    e. Tooling
       i. Elm REPL
       ii. Elm Make
       iii. Elm Package Manager (semver enforced)
       iV. Elm Reactor
    f. ffi
V. Elm Feature
   a. literals
   b. functions
      i. currying
      ii. pattern matching
      iii. conditionals
      iv. let/in
      v. application
   c. simple structures
      i. lists
      ii. tuples
   d. ADTs
      i. sum (union)
      ii. product
   e. records
      i. accessors
      ii. pattern matching
      iii. row polymorphism (structural typing / static duck typing)
      iv. update, remove, etc.
      v. immutable
   f. types
      i. everything has a type
      ii. function types
      iii. aliases
VI. Examples
    a. Simple Elm HTML with start-app
       i. similarities to react / flux
       ii. elm architecture
    b. Simple Canvas with Signals
V. Further
   a. 