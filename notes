A Gentle Introduction To Elm

What is Elm
     A statically typed, functional language from the browser
     Immutable data
     Designed for Functional Reactive Programming
     Concise syntax, currying, pattern matching
     Advanced type system

Installing Elm
    http://elm-lang.org/try
    http://elm-lang.org/install
      installers for windows & OSX
      install from source requires Haskell (cabal etc)

Syntax
    Literals
        Literals look like you might expect
                 42 : number (could be Int or Float)
                 3.14 : Float
                 True
                 'a' : Char
                 "a" : String
                 """
                 Multiline
                 strings
                 """
        Different types for Int & Float
        Different literals from Char and String
        Don't forget lists
              Lists are a core data structure in many functional languages & Elm is no exceptions
              [1, 2, 3, 4] == 1 :: 2 :: 3 :: 4 :: []
                  (::) is an operator that adds an element to a list and [] is an empty list
              ranges
                  [1..10]
    Functions
        function definitions in Elm look like:
                 add x y = x + y
        function application looks like:
                 add 10 10
                 -- 20
        anonymous functions look like:
                  \x -> x + 10
        Currying
          Technically speaking, currying is taking a function with multiple arguments
          and transforming it into multiple functions that each take a single function
          In Elm, and Haskell alike, this means that functions only take one argument
          and return a function that takes the next argument
          Functions are automatically curried
                    add x y = x + y == add x = \y -> x + y
          Which means you can _partially_ _apply_ a function to make a new one
                    add10 = add 10
                    add10 10
                    -- 20
          But you don't have to write functions any differently, it's just there.
          Here's a quick example:
                 map (\x -> x + 10) [1..10]
                 -- [11, 12, 13, 14, 15, 16, 17, 18, 19, 20]

                 map (add 10) [1..10]
                 -- [11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
        Pattern matching
                Allows you to define different function bodies for different types of data
                You can kind of think of them as cases in a switch statement
                    f True = "This is true."
                    f False = "This is false."
                Here we define a function 'f' that has two different behaviors depending on the value passed to it
        Conditionals
            if _ then _ else _
               Elm has if statements, I don't know enough about the Elm community to know if they are considered
               "bad style", but they are in similar languages. This is because other language constructs provide
               better options.

               Elm, like Haskell, requires the 'else' in the 'if/then/else' there is no 'if/then'
            "multi-way" if (guards in Haskell)
               In addition to pattern matching, Elm has 'multi-way if' statements which are even more
               like cases in a switch statement. Where pattern matching allows you to match on values
               'multi-way' if allows you to test those values and provide different definitions for each
               case
                  f x =
                    if | x < 10 -> "Less than"
                       | x > 10 -> "Greater than"
                       | otherwsie -> "Equal"
               Both pattern matching and 'multi-way if' evaluate from top to bottom. Specific cases
               need to preceed generic ones.
        Let
            Let-expressions allow you to store values with a more limited scope. Unlike top-level functions
            they aren't exposed outside the function that defines them.
        Application
            Function application is done use space delimited arguments, no parens, no commas
                     f x y = ...

                     f 10 20
            Elm has infix operators that _do_ work like you would expect
                    10 + 20 = 30
            Elm has standard arithmatic infix operators (+, -, *, /) and generally figures out the types
            by the arguments passed
                   10 + 20 : number (could be Int or Float)
                   10.5 + 20 : Float
            However, there are two options for division, one for each number type
                     100 // 2 : Int
                     100 / 2 : Float
            But operators are just functions that have special characters as names
                      (+)
                      (*)
                      (/)
                      (::)
                      and so on
            Since operators are just functions, you can do things like
                      ((+) 1) 2
                      add10 = (+ 10)

            Tuples have an interesting infix operator used for construction:
                       (,) is a function for create a tuple with 2 values
                       (,,) is a function for creating triples
                       (,,,) and so on.
            Of course, you don't have to use them in this way to create tuples:
                       (,) 1 2 == (1,2)
                       (,,,)  == (True, 1, 'a', "Foo")

    Operators
          Operators are just functions
          Pipe
          Composition


    Algabraic Data Types
        So called because there is an algebra for determining how many inhabitants a type can have,
        thus giving us a way to reason about how many values a function has to handle.
        Functions that can properly handle all inhabitants are said to be "total" functions,
        while those that do not are "partial". For example a function that expected a list, but
        provided no implementation for an empty list is partial.

        Sum (Union Types)
            So called because the number of inhabitants of the type is the _sum_ of the possible
            values. You can think of it as 'or'. For example:

                    type Action
                         = SayHi
                         | SayBye
                         | LaunchMissles
            The pipe is the 'or', so the type Action is any one of those three values, but only ever one.
            The number of inhabitants is 3 (SayHi + SayBye + LaunchMissles)

            Sum types can hold additional values as well

                      type Action
                           = Increment
                           | Decrement
                           | Delete Int
            Here the possible values are Increment, Decrement or Delete (with some Int value); in order to have
            a valid Delete value, we must have a valid Int along with it. The number of inhabitants goes up
            considerably here (1 + 1 + the number of possible valid integers).

            Sum types can be polymorphic. The List type, is on example (it's also recursive but nevermind that)
                      type List a
                           = Nil 
                           | Cons a (List a)
            Sum/Union types are similiar to enumerations in languages like Java or C#. The provide a type-safe
            way to refer to concepts in our program without resorting to strings, or numbers.

            You use these types when pattern matching in functions. For example
                f SayHi         = ...
                f SayBye        = ...
                f LaunchMissles = ... -- probably bad

        Product Types
           So called because the number of inhabitants is the product of the number of inhabitants for each field.
           For example:
               type Person = Person String String Int
               Person "Jesse" "Williamson" 35
           To figure out the number of inhabitants (String x String x Int) o_O
           This might seem a strange way to model a person given most languages have some kind of object syntax
           And you'd be right
        Records
            Records are product types, but they provide a familiar syntax and allow us to name our fields
                    { firstName : String
                    , lastName  : String
                    , age       : Int
                    }

            This syntax is far more common in Elm, but the resulting data structure is essentially the same.
            One nice thing though is Elm provides us with field accessor functions for each field in our record.
                     jesse = { firstName = "Jesse", lastName = "Williamson", age = 35 }
                     jesse.firstName -- "Jesse"
                     .firstName jesse -- "Jesse"

            Records in Elm are extensible, there are functions for removing, updating, renaming and adding fields.
            Although those names are usually associated with mutation, each of these will return a brand new
            record leaving the original unchanged.

            Records can be used in pattern matching
                    greet {first, _, _} = "Hello, " ++ first ++ last
                    greet jesse -- "Hello, Jesse Williamson"
            Row polymorphism
                Another nice feature of records in Elm is row polymorphism. It allows us to define functions
                that work with any record that has specifically named field of a specific type. We can define
                a greet function that works one any record has a firstName field rather than one that works only
                one specific type of record
Types
    Anatomy of a type signature
            Everything in Elm has a type, but because of its type inference allows you to ommit them
            However, it is good practice to include type signatures on all top-level declarations.
            Here are some examples of Elm type signatures
                 1 : number
                 1.5 : Float
                 'a' : Char
                 "Hello" : String
           The : can be read as "has the type." So 1.5 "has the type" Float
           Type signatures for functions get more interesting
                f : Integer -> Integer
           This functions type tells us both number of arguments, their type and the type of the returned value.
           Since functions are values like anything else, they can be passed in to, or returned from functions.
                 map : (a -> b) -> [a] -> [b]
           Functions in a type signature use the same "arrow" syntax, but are wrapped in parens.
           The type signature also illustrates that function types can be polymorphic. The type signature
           for map says that, given a function that can turn an 'a' to a 'b', it can turn a list of 'a' in a list of 'b'
           The signature also says that 'a' and 'b' can be different types, but they don't need to be. However, this type
               f : (a -> a) -> [a] -> [a]
           All the 'type variables' are the same, so all of the types must be as well.
    Type Aliases
         Aliases allow us to give existing types names that are more meaningful to our program

                 type alias Person =
                      { name : String
                      , age : Int
                      }

                 type alias Greeting = String

                 greet : Person -> Greeting
                 greet person = ...

Modules 
FFI
    Mention but don't go into detail (Ports)

Elm HTML
    model, update, view
    actions
    Quick example
    Mention signals but it's too big to deal with now
    Elm Architecture

The Elm Compiler
    One of the nicest compilers you'll ever use
    Certainly the most helpful compiler errors I've seen
    Fast. Really fast.

Elm Package Manager
    Installs packages, and updates the elm-package.json
    Nice little UI for confirm installation plans
    Basically what you would expect from a PM
    elm-package.json, elm-stuff

Elm REPL
    Your basic REPL for Elm. Nothing too fancy
    Requires node.js
    https://github.com/elm-lang/elm-repl

Elm Reactor
    Interactive development environment
    Allows you to automatically compile your Elm code
           It won't load your HTML file with styles, etc., only Elm code
    Provides hot-swapping and a time-travelling debugger
    Navigate to your project, run elm-reactor and hit localhost:8000 for a list of files.
    The time-travelling debugger allows you to pause, rewind, and replay from any point in your
    programs execution (a la Bret Victor's 'Inventing On Principle'). Code hot-swapping allows you
    to edit your source files, while keeping your recorded events. Meaning you can replay them and see
    what effect they have your application.

----------------------------------------------
----------------------------------------------
Why FP matters
Things about FP
Maintainability
"I don't want to learn something new

----------------------------------------------
----------------------------------------------
Jessica Kerr Elm Talk
Breaking things apart and putting them back together
Composition
Declaritive
Isolation
Data Flow -> One way

Elm is like React / Flux, but at the language level, not simply at a library / framework level
React -> Components -> JSX (which is just a HTML DSL) -> Describes what the DOM looks like for a given state -> Compose components to make larger ones -> Unidirectional Data flow
Elm -> Modules (Components) -> Elm-Html (which is just an HTML DSL) -> Describes what your DOM should look like for a given state -> Actions relevant to your component -> Update function to handle actions -> Compose components to make larger ones -> Unidirectional Data flow

Components in React are nouns. Instatiations of some React Class
Components in Elm are a collection of verbs. When a parent component wants to do something to a child, it just calls a function

Rather that Red Test -> Code -> Green Test or Code -> Manual Test -> Code, it's Code -> Compile Error -> Code -> Compiled

There is no undefined / null

"Tie our hands to free our minds" - We put constraints on the things we can do in our code & with our data so that we can better understand how they work.

Components in Elm are slightly more complicated than React in that outter components have to manage inner components. However, a component really only needs view/model/update

-----------------------------------------------
-----------------------------------------------
Lets Be Mainstream
https://www.youtube.com/watch?v=oYk8CKH7OhE

Maintainability
Typed functional languages with good inference gets all of your types under control without really heavy syntax

Usability
Increasing the time from novice to getting something done.

Javascript is highly usable (as far as getting running quickly), but maintainability becomes difficult.
Gradual Types keeps initial usability high, and lets you add types to help maintainability as you need it.
What's the end game? If you have a JavaScript program that is fully typed, is it JavaScript? Did we just turn it into Java?
Elm is designed with FE devs in mind.
With these principles
    Gradual learning     -> A nice learning curve. Langs like JS and Python have this. Many FP langs don't.
                         -> As users get more comfortable, and more advanced they start to realize the more advanced concepts.
                         -> start-app as an example
                         -> "Crazy Concepts" -> I hate this idea
    Communication        -> Be direct with language ("pure function -> stateless function", "easy to reason about -> easy to refactor", "safe -> reliable", "monad -> callback"
                         -> Elm doesn't use Functors, Monoids, Monads etc, BUT the pattern is there.
                         -> Obvious names "elm-make" "elm-package" "elm-html"
                            -> Elm style guide
    Culture              -> Community
                         -> ML langs are harder to read because the allow for various coding styles and indentation
                         -> Elm style guide for code style
                         -> Package Guide
    Usage-driving Design -> Minimal viable solution
                         -> Static signals -> Elm Architecture (you can't change how signals flow through your program) see Redux
                         -> No type classes (JS programmers love it, Haskell programmers hate it) Think about when you release a feature.
                         -> "Simpler foundation produces simpler code in practice"
    Tooling              -> Build unique and delightful experiences in tooling
                         -> REPL, Reactor, Nice compiler, Debugger
                         -> Auto Sem-Ver packaging enforces rules by checking types and prevents you from packaging if you don't follow the rules
                         -> Friendly error messages
                            /compiler-errors-for-humans
                         -> Faster than JS?
                         -> Provide experiences that you can't get elsewhere
Elm is designed to compete.

-----------------------------------------------
-----------------------------------------------

Controlling Time & Space
Evan Czaplicki
https://www.youtube.com/watch?v=Agu6jipKfYw

"First-order FRP" - How Elm does it
    Gives events in time a specific structure (Signal Graph)
    Inputs from the world
    Signals are values that change over time.
    As time passes, the value (Mouse.position : Signal (Int, int)) changes
    Transform signals (lift aka fmap if you consider Signals a Functor)
    State foldp (fold from the past)A
    Merge (merge, lift2)
        merge combines signals of the same type
        lift2 combins signals of different values
    computer -> inputs -> transformations -> output -> computer

    Core Design
        Signals are connected to the world
        Signals are infinite no deleting, no throwing away inputs to your program are fixed
        Signal graphs are fixed
        Sync by default events flow through in the correct order

    Benefits of Elm
        Efficiency
        Architecture (Elm architecture)
                    build UI is nice declaritive way
        Hot-swapping
        Time-travel debugger
        These things come from having a static signal graph

"Higher-order FRP"
   Signal graphs are not static
          As updates come in you can select what signal you're listening to
          What happens to old signals
          How do you deal with new signals
          What happens to state of those signals needs to maintain referrential transparency
          New signals may need infinite look back
              Only switch when safe
              Needs to be encoded in the type
   This is hard, needs more advanced type system
   Requires trade-offs, more complex

"Async Data Flow"
   Reactive programming in imperative languages
   No static signal graphs
   Finite signals
   Not sync -> sync has to be done by yourself
   Creates new signals
   Hot/Cold signals to determine what to do when signals aren't listened to

"Arrowized FRP"
   No static signal graphs
   Signals aren't connected to the world
   Elm has Automaton
       pure : (a -> b) -> Automaton a b
       state : s -> (a -> s -> s) -> Automaton a s
       (>>>) : Automaton a b -> Automaton b c -> Automaton a c
   Dynamic collections
   Gives up signals coming from the world
   About structuring code, means of abstraction

Each type is a different point in a design space
In Elm
   Higher order FRP -> Too many trade offs
   Async data flow -> Lose sync, but you could hook up that system to Elm
   Arrowized FRP -> You can just create this as a library
Elm is about keeping things as simple as possible.
-----------------------------------------------
-----------------------------------------------
My Advernture With Elm
Yan Cui
https://www.youtube.com/watch?v=cBVXyxt-9_Q

Not an expert in Elm

Quick overview of FRP
Transformation vs mutation
Dave Thomas transformations easier than maintaining state
Functions provide mapping from state -> state
Simply proble decomposition
Clear separation of concerns. Pure/Inpure
Compose Input -> Transform -> Effect
Observable = Stream = Signal
Inventing of Principles
Perf
Basics
  -> functions
  -> types
  -> currying
     -> "fixing the first argument"
     -> methods with multiple arguments are like tupes
  -> let ... in
     -> vs assignment
  -> Lambda
     -> currying operators
  -> tuples
     -> (,) operator
  -> Records
     -> accessors
     -> extensiblility
     -> polymorphic
     -> row polymorphism
  -> ADT
  -> Currying + Pipes
  -> Currying + Composition
  -> Conditionals
  -> Signals
-----------------------------------------------
-----------------------------------------------
Functional Reactive Programming in Elm
Evan Czaplicki
https://www.youtube.com/watch?v=F-nTU3Wy26I

Functional Graphics
talks about the motivations behind Elm and how that lead to FRP
 
-----------------------------------------------
-----------------------------------------------
Pretty much every JS project has a build step, even if it's just uglifying and minifying your code.
Lots of us are transpiling using Babel. If you use React you're doing something with JSX. You've got
tools designed to add types to JavaScript (Flow, React Prop Types), or even TypeScript.

Essentially, you're writing JavaScript(ish) code. Why develop these tools, but we insist that it's still
JS (and maybe its is), but why not reach for another tool? Why not reach for a language that has these concepts
at its core, rather than adding after the fact.

Pure functions all the way down, always returns the same thing, even I/O functions.
immutable data -> data doesn't change. If someone changes the data you need out from under you, your data isn't changed.
