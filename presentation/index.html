<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Elm – Typed Functional Programming For The Web</title>

    <meta name="description" content="Full Stack San Diego slides">
    <meta name="author" content="Jesse Williamson">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/sky.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/solarized_dark.css">

    <!-- Printing and PDF exports -->
    <script>
     var link = document.createElement( 'link' );
     link.rel = 'stylesheet';
     link.type = 'text/css';
     link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
     document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <h1>Elm</h1>
          <h6>Typed Functional Programming For The Web</h6>
        </section>
        <section>
          <section>
            <h2>Let's Talk About JavaScript</h2>
          </section>
          <section>
            <h2>YAY!</h2>
            <ul>
              <li>It's everywhere</li>
              <li>Super easy to run</li>
              <li>Simple, but powerful</li>
            </ul>
            <aside class="notes">
              <ul>
                <li>JavaScript is everywhere and there are hundreds of thousands of packages for it</li>
                <li>All you need to get going, really, is a browser. Pop open devtools and you can run commands in the console</li>
                <li>Beyond that, todays frameworks and libraries make it dead simple to get an app running</li>
                <li>The language is pretty simple, but it comes with some powerfule features (functions as first-class values)</li>
              </ul>
            </aside>
          </section>
          <section>
            <h2>OMG WTF AYFKM GTFO!</h2>
            <ul>
              <li>WTF is equality even</li>
              <li>MUTABLE ALL THE THINGS</li>
              <li>Maintenance?</li>
            </ul>
            <aside class="notes">
              <ul>
                <li>JavaScript is a trainwreck in a lot of ways</li>
                <li>We could sit a talk about them all night, which is fun, but we've probably all seen the WTFs on twitter or whatever</li>
              </ul>
            </aside>
          </section>
          <section>
            <h2>JavaScript is improving</h2>
              <p>ES 2015 & beyond</p>
              <p>"Best practices" are being challenged</p>
              <p>Maintenance issues are being addressed</p>
            <aside class="notes">
              <ul>
                <li>The language is improving, and getting some much needed TLC</li>
                <li>Things like two-way binding and property observation are being phased out thank in no small part to React</li>
                <li>Libraries like immutable.js and React, as well as tools like Flow are trying to change how we approach JavaScript to make it more manageable</li>
              </ul>
            </aside>
          </section>
          <section>
            <h2>But it's still JavaScript</h2>
            <p>For better or for worse</p>
            <aside class="notes">
                <p>As more features are added to the language, and pbraries add things pke types does it make sense to look at other languages</p>
            </aside>
          </section>
          <section>
            <h2>Enter Elm</h2>
            <aside class="notes">
              <ul>
                <li>Elm is a typed, functional language that compiles to HTML and JavaScript</li>
                <li>It is a language that has a lot of the concepts that JavaScript is just coming around to baked right in: immutability, reactivity, types, unidirectional data-flow</li>
              </ul>
          </section>
        </section>
        <section>
          <section>
            <h2>Why Functional Programming Matters</h2>
            <p>Oh God Not Monads</p>
            <aside class="notes">
              <ul>
                <li>Functional programming is getting a lot of attention recently</li>
                <li>Libraires like React and Flux are heavily inspired by it</li>
                <li>Others, like Ramda, take it a step further introducing more advanced concepts</li>
                <li>The JS community is getting a lot of inspiration from FP, but why?</li>
              </ul>
            </aside>
          </section>
          <section>
            <h2>Purity</h2>
            <p>x → y</p>
            <aside class="notes">
              <ul>
                <li>Functions operate on inputs only, and have no side effects</li>
                <li>Functions are referentially transparent, they always return the same output for a given input</li>
              </ul>
            </aside>
          </section>
          <section>
            <h2>Composition</h2>
            <p>f ∘ g</p>
            <aside class="notes">
              <ul>
                <li>Allows us to glue small functions together like a pipeline, each function feeds into the next</li>
                <li>We can keep functions small. Small is easy to reason about, small is easy to test</li>
              </ul>
            </aside>
          </section>
          <section>
            <h2>Higher Order Functions</h2>
            <aside class="notes">
              <ul>
                <li>Functions can be passed into other functions or returned from functions</li>
                <li>We can write abstract functions that allow us to customize them by passing in a function as an argument</li>
              </ul>
            </aside>
          </section>
          <section>
            <h2>Immutability</h2>
            <p style="text-decoration: line-through"> x = x + 1</p>
            <aside class="notes">
              <ul>
                <li>Immutable data makes code easier to think about</li>
                <li>You don't have to worry about your data being changed out from under you</li>
              </ul>
            </aside>
          </section>
        </section>
        <section>
          <section>
            <h2>Why Choose Elm?</h2>
          </section>
          <section>
            <h2>Designed For Frontend</h2>
            <aside class="notes">
              <ul>
                <li>Elm is designed to bring FP to FE devs, not FP devs to the Frontend</li>
                <li>It eschews concepts that exist in other Functional Langs (like Haskell)</li>
                <li>Concepts like Signals are key to the language, but pacakges are available to abstract that away</li>
              </ul>
            </aside>
          </section>
          <section>
            <h2>Easy to get up and running</h2>
            <p>Unless You're On Linux</p>
            <aside class="notes">
              <ul>
                <li>Easy installers for Windows and Mac</li>
                <li>Interactive examples to try it out</li>
                <li>Linux users (like me), have an install path, it's just not as simple</li>
              </ul>
            </aside>
          </section>
          <section>
            <h2>Tooling</h2>
              <p>Elm REPL</p>
              <p>Elm Make</p>
              <p>Elm Package Manager</p>
              <p>Elm Reactor</p>
            <aside class="notes">
              <ul>
                <li>Elm provides a REPL. Nothing to fancy but it's good for testing things out</li>
                <li>Elm Make is simple build system</li>
                <li>Elm Package Manager is a (yet another) package manager. It provides nice installation plan. It enforces SemVer.</li>
                <li>Elm Reactor provides easy re-compilation (just refresh the page) of a project, hotswapping and a time-traveling debugger (think Brent Victor Inventing On Principle).</li>
              </ul>
            </aside>
          </section>
        </section>
        <section>
          <section>
            <h2>The Elm Language</h2>
          </section>
          <section>
            <h2>Literals & Operators</h2>
            <pre><code>
num = 43

flt = 12.3

str = "hello"

char = 'a'

mult =
"""
Hello
World
"""
            </code></pre>
            <pre><code>
1 + 1

"Hello" ++ "World"

True && False
            </code></pre>
          </section>
          <section>
            <h2>Functions</h2>
            <p>The Basics (1/3)</p>
            <pre><code>
add x y = x + y

add 10 11 -- 21

add 10    -- returns a function that has its first argument fixed to 10

add' = (\x y -> x + y) -- anonymous function
            </code></pre>
          </section>
          <section>
            <h2>Functions</h2>
            <p>Pattern Matching (2/3)</p>
            <pre><code>
or b1 b2 =
  case b1 of
    True -> True
    False -> b2
            </code></pre>
          </section>
          <section>
            <h2>Functions</h2>
            <p>Let (3/3)</p>
            <pre><code>
f x =
  let
    double = x * 2
  in
    double + double
            </code></pre>
          </section>
          <section>
            <h2>Notes On Functions</h2>
              <p>Operators are just functions; you can create your own</p>
              <p>Functions & operators can be used prefix or infix</p>
            <pre><code>
(<<>>) x y = x + y

3 <<>> 3

(<<>>) 3 3

(+) 3 3

add 3 3

3 `add` 3</code></pre>
          </section>
          <section>
            <h2>Lists</h2>
            <pre><code>
xs = [1, 2, 3]

4::xs -- [4, 1, 2, 3]

head xs
  case xs of
    x::xs -> Just x
    []    -> Nothing

List.map (\x -> x + 1) xs

List.map ((+) 1) xs
            </code></pre>
          </section>
          <section>
            <h2>Tuples</h2>
            <pre><code>
t = (1, "Foo")
t' = (2, "Bar", [1, 2, 3])

fst t -- 1
snd t' -- "Bar"

(,) 1 2
(, ,) 1 2 3
            </code></pre>
          </section>
          <section>
            <h2>Union Types</h2>
            <p>aka Sum Types</p>
            <pre><code class="elm">
type Action =
  Add
| Sub
            </code></pre>
            <pre><code>
calc action n m=
  case action of
    Increment -> n + m
    Decrement -> n - m

calc Add 1 2 -- 3

calc Sub 5 3 -- 2

            </code></pre>
          </section>
          <section>
            <h2>Union Types</h2>
            <p>With Values</p>
            <pre><code class="elm">
type Action =
  Increment
| Decrement

type Counter = Counter Int
            </code></pre>
            <pre><code>

step action (Counter n)=
  case action of
    Increment -> Counter (n + 1)
    Decrement -> Counter (n - 1)

step Increment (Counter 1) -- Counter 2

step Decrement (Counter 2) -- Counter 1
            </code></pre>
            <aside class="notes">
              <ul>
                <li>This example is fairly trivial, but the point is that each value of a type can carry data</li>
                <li>The point is they can hold any data</li>
              </ul>
            </aside>
          </section>
          <section>
            <h2>Polymorphic Unions</h2>
            <p>Product Types</p>
            <pre><code class="elm">
type Maybe a =
  Just a
| Nothing
            </code></pre>
            <pre><code>
head xs =
  case xs of
    x::xs = Just x
    [] = Nothing
            </code></pre>
            <pre><code>
type Either a b = Left a | Right b
            </code></pre>
            <aside class="notes">
              <ul>
                <li>Sum types can carry data with them, and we can parameterize that data</li>
                <li>Maybe a isn't a "concrete" type, it's a like a function waiting for an argument</li>
                <li>Maybe Int & Maybe Char are unique types</li>
              </ul>
            </aside>
          </section>
          <section>
            <h2>Records</h2>
            <p>Defining & Accessing</p>
            <pre><code class="elm">
person = { first = "Jane", last = "Smith" }

person.first -- "Jane"

.last person -- "Smith"

List.map .last people -- a list of last names

sayHi { first } =
  "Hi " ++ first

sayHi person -- "Hi Jane"
            </code></pre>
            <aside class="notes">
              <ul>
                <li>Records are like objects / hashes in other languages</li>
                <li>But records in Elm are far more powerful than, say, objects in JS</li>
                <li>They are also very similar to n-tuples or a sum type containing various values</li>
                <li>Records, however, come with accessors (which are just functions), provide a more familiar interface</li>
              </ul>
            </aside>
          </section>
          <section>
            <h2>Records</h2>
            <p>Updating</p>
            <pre><code class="elm">
{ person - first } -- removes a field

{ person | age = 20 } -- adds a new field & value

{ person | first <- "John" } -- updates a field

{ person - last | surname = "Smith" } -- combine adding & deleting to rename a field
            </code></pre>
            <aside class="notes">
              <ul>
                <li>Important note here, this is not mutation, data is immutable.</li>
                <li>Each operation creates a new record, using the source as a template</li>
              </ul>
            </aside>
          </section>
          <section>
            <h2>Types</h2>
            <p>The Part Where Everyone Stops Listening</p>
            <aside class="notes">
              <ul>
                <li>The idea of a statically typed languages turns a lot of people off</li>
                <li>But notice that none of the previous examples have type annotations</li>
                <li>Yet each expression has a type and is statically checked at compile time</li>
                <li>Elms type inference sorts all of that out</li>
                <li>You don't NEED to annotate your code, but you should.</li>
                <li>Types can help guide an implmentation, and they provide documentation</li>
              </ul>
            </aside>
          </section>
          <section>
            <h2>Types</h2>
            <p>Values</p>
            <pre><code class="elm">
5 : number

4.5 : Float

"Hi" : String

'c' : Char

Increment : Action

Just "Hi" : Maybe String

Keyboard.presses : Signal Int

person : {first : String, last : String}
            </code></pre>
            <aside class="notes">
              <ul>
                <li>Numbers in Elm can be a float or an int, but Elm also includes the broader 'number'</li>
                <li>number is a type that could be a Float or an Int depending on the usage</li>
                <li>Signals play a HUGE role in Elm. Unfortunately, the topic is too large to get into now</li>
              </ul>
            </aside>
          </section>
          <section>
            <h2>Types</h2>
            <p>Functions 1/2</p>
            <pre><code>
add : Int -> Int -> Int
add x y = x + y

intMap : (Int -> Int) -> List Int -> List Int
            </code></pre>
            <aside class="notes">
              <ul>
                <li>The type of a function includes a list of types of arguments, separated by '->'</li>
                <li>The final type in the signature is the return type</li>
              </ul>
            </aside>
          </section>
          <section>
            <h2>Types</h2>
            <p>Functions 2/2</p>
            <pre><code>
add : Int -> Int -> Int

add3 : Int -> Int -> Int -> Int

List.map : (a -> b) -> List a -> List b

-- Curried Versions

add : Int -> (Int -> Int)

add3 : Int -> (Int -> (Int -> Int))

List.map : (a -> b) -> (List a -> List b)
            </code></pre>
            <aside class="notes">
              <ul>
                <li>Functions in Elm are curried</li>
                <li>Each function takes one argument and returns a new function of one argument</li>
                <li>The paranthesis help illustrate that point. For each argument</li>
                <li>They also show an interesting way to look at map</li>
                <li>map is really a function that takes a function which works on a single value</li>
                <li>And turns it into a function that works on a list of values</li>
              </ul>
            </aside>
          </section>
          <section>
            <h2>Types</h2>
            <p>Polymorphic Functions</p>
            <pre><code>
id : a -> a

List.map : (a -> b) -> List a -> List b

(::) : a -> List a -> List a
            </code></pre>
          </section>
          <section>
            <h2>Type Aliases</h2>
            <pre><code>
type alias Text = String

type alias Size = Int

type alias Name = { first : String, last : String }

type alias Person = { name: Name, age: Int }

type alias Named a = { a | name : Name }
            </code></pre>
          </section>
        </section>
        <section>
          <section>
            <h2>Examples</h2>
          </section>
        </section>
        <section>
          <h2>Further</h2>
          <ul>
            <li><a href="http://elm-lang.org">Elm Lang</a></li>
            <li><a href="https://www.youtube.com/watch?v=1uRC3hmKQnM">Functional Principles in React</a> - Jessica Kerr</li>
            <li><a href="https://www.youtube.com/watch?v=FV0DXNB94NE">Make the Backend Team Jealous...</a> - Richard Feldman</li>
            <li><a href="https://www.youtube.com/watch?v=cBVXyxt-9_Q">My Adventure With Elm</a> - Yan Cui</li>
            <li><a href="https://www.youtube.com/watch?v=oYk8CKH7OhE">Let's Be Mainstream...</a> - Evan Czaplicki</li>
            <li><a href="https://www.youtube.com/watch?v=Agu6jipKfYw">Controlling Time and Space...</a> - Evan Czaplicki</li>
            <li><a href="https://pragmaticstudio.com/elm">Building Reactive Web Apps</a> - The Pragmatic Studio</li>
            <li><a href="https://pragmaticstudio.com/elm-signals">Signals, Mailboxes & Ports</a> - The Pragmatic Studio</li>
          </ul>
        </section>
        <section>
          <h2>Thanks!</h2>
          <p><a href="https://twitter.com/thunk_life">@thunk_life</a></p>
          <p><a href="https://thunklife.github.io/elm-talk">https://thunklife.github.io/elm-talk</a></p>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

     // Full list of configuration options available at:
            // https://github.com/hakimel/reveal.js#configuration
     Reveal.initialize({
       controls: true,
       progress: true,
       history: true,
       center: true,

       transition: 'slide', // none/fade/slide/convex/concave/zoom

       // Optional reveal.js plugins
       dependencies: [
         { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
         { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
         { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
         { src: 'plugin/highlight/highlight.js', async: false, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() {
           hljs.configure({languages: ['Elm']});
           hljs.initHighlightingOnLoad(); } },
         { src: 'plugin/zoom-js/zoom.js', async: true },
         { src: 'plugin/notes/notes.js', async: true }
       ]
     });

    </script>

  </body>
</html>
